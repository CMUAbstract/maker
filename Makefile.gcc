PREFIX = $(RISCVGCC_ROOT)/bin/riscv32-unknown-elf-
CC      = $(PREFIX)gcc
GCC		= $(CC)
LD      = $(PREFIX)gcc
AS      = $(PREFIX)as
GDB     = $(PREFIX)gdb

include $(MAKER_ROOT)/Makefile.version.gcc

LINKER_SCRIPT = $(MAKER_ROOT)/linker-scripts/link.ld

include $(MAKER_ROOT)/Makefile.suffix

OPT_LEVEL ?= 3

COMMONFLAGS =

CC_LD_FLAGS =

ASFLAGS_TOOLCHAIN = \
	$(COMMONFLAGS) \

# We override because when this file is included from a nested build directory
# (say, when the app or toolchain has more than one build artifact, each built
# by its own makefile), the CFLAGS are passed via '$(MAKE) -e', with which
# changing the value of a variable is only possible with override. It's ugly,
# but hopefully, this is enough to make things work.

CFLAGS_TOOLCHAIN += \
	$(COMMONFLAGS) \
	$(CC_LD_FLAGS) \
	-O$(OPT_LEVEL) \
	-march=rv32em \
	-mabi=ilp32e \
	-g \
	-std=c99 \
	-Wall \
	-I$(SRC_ROOT) \

CFLAGS_TOOLCHAIN +=

LFLAGS_TOOLCHAIN += \
	$(COMMONFLAGS) \
	$(CC_LD_FLAGS) \
	-T $(LINKER_SCRIPT) \
	-Wl,--gc-sections \

VPATH = $(SRC_ROOT)

bin: $(BIN)

-include $(OBJECTS:.o=.d)

# disable implicit rule that for some reason overrides the chained rules below
#.SUFFIXES:

%.o: %.c
	mkdir -p "./$(shell dirname $@)"
	$(CC) -c -MD $(CFLAGS_TOOLCHAIN) $(CFLAGS) $< -o $@

%.o: %.S
	mkdir -p "./$(shell dirname $@)"
	$(AS) $(ASFLAGS_TOOLCHAIN) $(ASFLAGS) $< -o $@

%.out: $(OBJECTS)
	$(LD) $(LFLAGS_TOOLCHAIN) $(LFLAGS) $(OBJECTS) $(LIBS) -o $(BIN)

%.a: $(OBJECTS)
	$(AR) rcs $@ $^

clean:
	rm -f $(OBJECTS) $(OBJECTS:.o=.d) $(BIN)

debug: $(BIN)
	$(GDB) $(BIN)

ifeq ($(TARGET_TYPE),exec)
define add-lib
LIBS += -l$(subst lib,,$(1))
override LFLAGS += -L$$(DEP_LIB_DIR_$(1))
endef
else # TARGET_TYPE
define add-lib
# nothing
endef
endif

include $(MAKER_ROOT)/Makefile.common
