# Declare a dependency on a library
# $(1) : library name
# $(2) : library build directory
# $(3) : library name suffix
# $(4) : toolchain
#
# This includes the library into the build and creates rules for making the
# library and cleaning it, as well as aggregate rules 'dep' and 'depclean'.
#
# Usage: $(eval $(call depend,libxxx))
#
# The library is expected to be in $(LIB_ROOT).
#
# TODO: It might be worth it to parametrize the path for each library (in
# the dependency declaration), but that's more verbose. It should be
# possible to make the path argument optional.

define depend-rule

$(2):
	mkdir -p $(2)

$(2)/$(1).$(3): $(2)
	$$(MAKE) TOOLCHAIN=$(4) -e -C $$^ -f ../../Makefile

# Only add dependency for executables, not libraries.  Can't have it for libs,
# because we use dep array in the recipe for linking objects into libraries.
ifeq ($(TARGET_TYPE),exec)
$(BIN): $(2)/$(1).$(3)
endif # TARGET_TYPE

dep: $(2)/$(1).$(3)

depclean_$(1): $(2)
	$$(MAKE) TOOLCHAIN=$(4) -C $$^ -f ../../Makefile clean
depclean: depclean_$(1)

endef

define depend

# $(1): library name
# $(2): toolchain to use to build the library (may differ from app's toolchain)

# These are designed to be overriddable from top-level app makefile
DEP_ROOT_$(1) ?= $(LIB_ROOT)
DEP_RELDIR_$(1) ?= $(1)
DEP_INC_RELDIR_$(1) ?= src/include
DEP_BLD_RELDIR_$(1) ?= bld
DEP_LIB_RELDIR_$(1) ?= $$(DEP_BLD_RELDIR_$(1))/$(2)

DEP_TOP_$(1) = $$(DEP_ROOT_$(1))/$$(DEP_RELDIR_$(1))
DEP_INC_$(1) = $$(DEP_ROOT_$(1))/$$(DEP_RELDIR_$(1))/$$(DEP_INC_RELDIR_$(1))
DEP_LIB_DIR_$(1) = $$(DEP_ROOT_$(1))/$$(DEP_RELDIR_$(1))/$$(DEP_LIB_RELDIR_$(1))
DEP_BLD_DIR_$(1) = $$(DEP_ROOT_$(1))/$$(DEP_RELDIR_$(1))/$$(DEP_BLD_RELDIR_$(1))

# We override because when this file is included from a nested build directory
# (say, when the app or toolchain has more than one build artifact, each built
# by its own makefile), the CFLAGS are passed via '$(MAKE) -e', with which
# changing the value of a variable is only possible with override. It's ugly,
# but hopefully, this is enough to make things work.

override CFLAGS += -I$$(DEP_INC_$(1))

$(eval $(call add-lib,$(1),$(2)))
$(call depend-rule,$(1),$$(DEP_LIB_DIR_$(1)),$(call bin-suffix,lib,$(2)),$(2))

# Application may want to use the library config flags as well.
# In particular, if library defines an ISR handler for the app to insert it
# into an ISR, then the app needs library's pin macros.
-include $$(DEP_TOP_$(1))/Makefile.config
-include $$(DEP_TOP_$(1))/Makefile.options

# Some libraries have customized recipies for linking against them
-include $$(DEP_TOP_$(1))/Makefile.target
endef

# Also clean the app when cleaning dependencies
depclean: clean

define unique
$(if $(filter 0 1, $(words $(1))),\
     $(1),\
     $(if $(filter $(firstword $(1)), $(wordlist 2, $(words $(1)), $(1))),\
          $(call unique, $(wordlist 2, $(words $(1)), $(1))),\
          $(firstword $(1)) $(call unique, $(wordlist 2, $(words $(1)), $(1)))))
endef # unique

# Syntax of each entry in DEPS and DEPS_toolchain is libname[:toolchain]
$(foreach dep,$(call unique,$(DEPS) $(DEPS_$(TOOLCHAIN))),$(eval \
	$(call depend,$(word 1,$(subst :, ,$(strip $(dep)))),$(or \
                     $(word 2,$(subst :, ,$(strip $(dep)))),$(TOOLCHAIN)))))

# So that the nested call gets the CFLAGS settings from each lib's .options
export CFLAGS
